---
title: 'Implementing a CPU in systemverilog'
date: '2024-06-11'
tags: []
draft: false
summary: 'How to become one and meet other cracked engineers!'
images: ['/static/images/cpu.png']
---

# Implementing a CPU in verilog!

Creating a CPU from scratch might seem like a daunting task, especially with no prior experience in hardware design. However, it's a fascinating challenge that offers deep insights into the inner workings of computer architecture. Over the past week, I've been working on a project to build a minimal 32-bit ARM CPU using Verilog HDL (Hardware Description Language). I call it the VeriTiny CPU.

## Motivation

You might ask, "Why create a CPU from scratch?" My goal was to gain a thorough understanding of how CPUs operate and appreciate the complexity and elegance of these crucial components that power modern computing devices. This project was not just about learning but also about experiencing the intricacies of CPU design firsthand.

The VeriTiny CPU is designed to be a softcore ARM CPU, which means it's implemented entirely in Verilog HDL (Hardware Description Language).

## Architecture

The idea is to break down the CPU's operations into stages or pipelines, allowing multiple instructions to be processed simultaneously, thus improving performance.

### IFU

At the heart of this project lies the Instruction Fetch Unit (IFU), which fetches instructions from memory based on the program counter (PC) and feeds them into the Instruction Decoder.

### Decoder

The Decoder, as the name suggests, decodes these instructions and generates control signals to coordinate the operation of other units, such as the Register File, Arithmetic Logic Unit (ALU), and Data Memory Interface.

### Register

The Register File is like the CPU's personal diary, storing all the juicy data and temporary results.

### ALU

The ALU, on the other hand, is the muscle of the operation, performing arithmetic and logical operations on data from the Register File.

But how do we ensure smooth communication between all these components? Enter the Control Logic, the traffic cop of our CPU world. It coordinates the flow of data and control signals, making sure everyone plays nice and follows the rules.

### Pipelines

To keep things organized, I've divided the CPU's operations into five pipeline stages: Fetch (IF), Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB). Each stage is implemented as a separate module with its own set of pipeline registers, holding intermediate values and enabling data transfer between stages.
Of course, no system is perfect, and data hazards can occur when instructions depend on results from previous instructions that haven't been fully processed yet.

### Conclusion

Building the VeriTiny CPU has been an incredible learning experience. It provided a deep dive into CPU architecture, pipelining techniques, and Verilog HDL. This project has not only enhanced my technical skills but also deepened my appreciation for the complex engineering behind modern CPUs.

Happy coding, my fellow cracked engineers :)
